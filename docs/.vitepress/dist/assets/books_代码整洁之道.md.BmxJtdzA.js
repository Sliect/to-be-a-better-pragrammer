import{_ as l,c as a,o as i,a2 as e}from"./chunks/framework.CBOTroAR.js";const m=JSON.parse('{"title":"代码整洁之道","description":"","frontmatter":{},"headers":[],"relativePath":"books/代码整洁之道.md","filePath":"books/代码整洁之道.md"}'),o={name:"books/代码整洁之道.md"},t=e('<h1 id="代码整洁之道" tabindex="-1">代码整洁之道 <a class="header-anchor" href="#代码整洁之道" aria-label="Permalink to &quot;代码整洁之道&quot;">​</a></h1><h2 id="专业主义" tabindex="-1">专业主义 <a class="header-anchor" href="#专业主义" aria-label="Permalink to &quot;专业主义&quot;">​</a></h2><ol><li>清楚你要干什么</li><li>担当责任</li><li>确保代码正确运行</li><li>坚持学习</li><li>软件开发是马拉松，要保持体力，劳逸结合</li></ol><h2 id="tdd" tabindex="-1">TDD <a class="header-anchor" href="#tdd" aria-label="Permalink to &quot;TDD&quot;">​</a></h2><ol><li>在编好失败单元测试之前，不编写产品代码（先写失败用例，理清思路和临界点）</li><li>只要有一个单元测试失败了，就不要再写测试代码（简洁的快速迭代，单一职责）</li><li>产品代码恰好能让当前失败的单元测试成功通过，不要多写（搭积木，单一职责）</li><li>不断循环上述步骤，使测试用例和代码同步增加，如同抗体匹配抗原</li></ol><p>优点：</p><ol><li>确定性，测试用例是否通过</li><li>有效降低Bug数</li><li>有勇气重构代码，大大的提高黑盒代码的掌控力</li><li>最好的文档</li><li>测试代码会要求你隔离出待测试的代码，此时你会去考虑函数的解耦，会迫使你考虑什么是好的设计</li></ol><p>缺点： 必须写出好的测试代码</p><h2 id="时间管理" tabindex="-1">时间管理 <a class="header-anchor" href="#时间管理" aria-label="Permalink to &quot;时间管理&quot;">​</a></h2><ol><li>注意力是稀缺资源</li><li>注意力分心智注意力和肌肉注意力</li></ol>',10),r=[t];function _(s,n,d,c,h,p){return i(),a("div",null,r)}const f=l(o,[["render",_]]);export{m as __pageData,f as default};
