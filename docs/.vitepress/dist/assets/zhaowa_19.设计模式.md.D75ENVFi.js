import{_ as a,c as e,o as t,a2 as i}from"./chunks/framework.CBOTroAR.js";const u=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"zhaowa/19.设计模式.md","filePath":"zhaowa/19.设计模式.md"}'),o={name:"zhaowa/19.设计模式.md"},l=i('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><ol><li>单一职责原则</li><li>开放封闭原则 (对扩展开放,对修改封闭)</li><li>里氏替换原则 (一个对象在其出现的任何地方，都可以用子类实例做替换)</li><li>接口隔离原则</li><li>依赖倒置原则 (高层模块不应该依赖于低层模块，解耦)</li></ol><p>面向对象设计</p><ol><li>模块划分，列出单一职责的需求描述，归类对象</li><li>过滤对象的名词作为属性，动词作为方法</li><li>定义对象之间的交互关系</li></ol><h3 id="创建型" tabindex="-1">创建型 <a class="header-anchor" href="#创建型" aria-label="Permalink to &quot;创建型&quot;">​</a></h3><p>工厂模式：规范创建步骤 将复杂对象通过一个工厂类创建</p><p>建造者模式：组合方案作为一个抽象类 适用于有多个构造参数时,将实体用链式的方法赋予属性,着重于一步一步构造一个复杂对象 比如 new Car(&#39;大众&#39;, &#39;SUV&#39;).setYear(2016).setOption(&#39;顶配&#39;)</p><p>单例模式：全局只有一个实例</p><h3 id="结构型" tabindex="-1">结构型 <a class="header-anchor" href="#结构型" aria-label="Permalink to &quot;结构型&quot;">​</a></h3><p>适配器模式：兼容适配</p><p>装饰器模式：动态将插件逻辑附加在对象上，类似插件</p><p>代理模式：代理对象可以在客户端和目标对象中间起中介作用，可以保护目标对象，即目标对象的抽象</p><h3 id="行为型" tabindex="-1">行为型 <a class="header-anchor" href="#行为型" aria-label="Permalink to &quot;行为型&quot;">​</a></h3><p>命令模式：调用者 =&gt; 命令 =&gt; 接受者，对行为调用者和接受者进行解耦</p><p>模板模式：确定好流程，并将每一步抽象，子类来实现这些步骤，即抽象固定框架后用子类实现</p><p>观察者模式：目标对象的状态发生改变，所有观察者对象都得到通知，建立一套触发机制，降低耦合性</p><p>责任链模式：为请求创建了一个接收者对象的链，对请求的发送者和接收者进行解耦</p><p>观察者模式和发布订阅模式的区别:<br> 发布订阅模式在发布者和订阅者之间有个调度中心（抽象代理），即发布者和订阅者之间完全解耦<br> 观察者模式则是观察者注册到，观察到目标状态改变后，再调度观察者，两者之间存在松耦合</p>',18),r=[l];function p(_,n,s,h,c,d){return t(),e("div",null,r)}const f=a(o,[["render",p]]);export{u as __pageData,f as default};
