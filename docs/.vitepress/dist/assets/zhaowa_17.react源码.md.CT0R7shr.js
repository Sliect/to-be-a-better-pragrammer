import{_ as e,c as r,o as t,a2 as o}from"./chunks/framework.CBOTroAR.js";const u=JSON.parse('{"title":"react源码","description":"","frontmatter":{},"headers":[],"relativePath":"zhaowa/17.react源码.md","filePath":"zhaowa/17.react源码.md"}'),a={name:"zhaowa/17.react源码.md"},i=o('<h1 id="react源码" tabindex="-1">react源码 <a class="header-anchor" href="#react源码" aria-label="Permalink to &quot;react源码&quot;">​</a></h1><p>js执行 =》 Layout =》 Paint</p><p>DOM<br> 真实DOM节点</p><hr><p>effect<br> 每个workInProgress tree节点上都有一个effect list 用来存放diff结果 当前节点更新完毕会向上merge effect list（queue收集diff结果）</p><hr><p>workInProgress<br> workInProgress tree是reconcile过程中从fiber tree建立的当前进度快照，用于断点恢复</p><hr><p>fiber<br> fiber tree与vDOM tree类似，用来描述增量更新所需的上下文信息</p><hr><p>Elements<br> 描述UI长什么样子（type, props）</p><h2 id="scheduler-调度任务的优先级-高优任务优先进入reconciler" tabindex="-1">Scheduler -- 调度任务的优先级，高优任务优先进入Reconciler <a class="header-anchor" href="#scheduler-调度任务的优先级-高优任务优先进入reconciler" aria-label="Permalink to &quot;Scheduler -- 调度任务的优先级，高优任务优先进入Reconciler&quot;">​</a></h2><p>Scheduler 使用 MessageChannel 的原因</p><ol><li>生成宏任务，将主线程还给浏览器，浏览器更新页面后继续执行未完成的任务</li><li>宏任务 =》 微任务 =》 浏览器渲染，微任务会在浏览器更新前就执行完，所以不能选择微任务</li><li>递归调用 setTimeout 会有4ms <a href="https://mp.weixin.qq.com/s/4P7ohpRmBChXQpLC-MHgHQ" target="_blank" rel="noreferrer">最小时延</a>的问题，会浪费 4ms资源</li></ol><h2 id="reconciler-负责找出变化的组件" tabindex="-1">Reconciler -- 负责找出变化的组件 <a class="header-anchor" href="#reconciler-负责找出变化的组件" aria-label="Permalink to &quot;Reconciler -- 负责找出变化的组件&quot;">​</a></h2><p>---------- render阶段 -----------</p><p>performSyncWorkOnRoot 或 performConcurrentWorkOnRoot 分别是同步，异步更新；异步更新会判断浏览器是否有空闲时间，如果有才继续遍历。</p><p>通过执行 performUnitOfWork(workInProgress) 来遍历 workInProgress，构成 Fiber 树。</p><p>beginWork 分为 mount 和 update，reconcileChildFibers 将 Fiber 节点赋值 effectTag。mountChildFibers 不会为 Fiber 节点赋值 effectTag，因为在挂载阶段只需将 rootFiber 节点赋值 Placement EffectTag，这样在 commit 阶段只需执行一次插入操作。</p><p>completeWork 针对不同的 fiber.tag （比如 HostComponent, FunctionComponent, ForwardRef, Fragrement 等等），调用不同的处理逻辑，然后再区分 mount 和 update来处理</p><p>在 completeWork 的上层函数 completeUnitOfWork 中，每个执行完 completeWork 且存在 effectTag 的 Fiber 节点会被保存在 effectList 的单向列表中。</p><p>遍历完 workInProgress 后，会生成一条以 rootFiber.firstEffect 为起点的单向链表，effectList 与 fiber树相比，就像圣诞树上挂的一串彩灯。</p><blockquote><p>rootFiber.firstEffect --nextEffect--&gt; fiber --nextEffect--&gt; fiber</p></blockquote><h2 id="renderer-负责将变化的组件渲染到页面上" tabindex="-1">Renderer -- 负责将变化的组件渲染到页面上 <a class="header-anchor" href="#renderer-负责将变化的组件渲染到页面上" aria-label="Permalink to &quot;Renderer -- 负责将变化的组件渲染到页面上&quot;">​</a></h2><p>---------- commit阶段 -----------</p><p>commit阶段分为 before mutation, mutation, layout 三个部分</p><p>穿插生命周期的回调函数，遍历 effectList ，根据 effectTag 执行不同的逻辑</p><h2 id="update-类比git-的一次-commit" tabindex="-1">Update -- 类比git 的一次 commit <a class="header-anchor" href="#update-类比git-的一次-commit" aria-label="Permalink to &quot;Update -- 类比git 的一次 commit&quot;">​</a></h2><p>fiber 节点上存在 updateQueue，存放多个 Update，因为可以多次调用 setState等操作来更新，current fiber 和 workInProgress fiber 分别有 updateQueue</p>',29),c=[i];function n(p,f,l,s,d,m){return t(),r("div",null,c)}const b=e(a,[["render",n]]);export{u as __pageData,b as default};
