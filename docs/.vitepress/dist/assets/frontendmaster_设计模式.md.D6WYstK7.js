import{_ as i,c as s,o as a,a2 as l}from"./chunks/framework.CBOTroAR.js";const g=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"frontendmaster/设计模式.md","filePath":"frontendmaster/设计模式.md"}'),p={name:"frontendmaster/设计模式.md"},n=l(`<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><h2 id="设计原则" tabindex="-1">设计原则 <a class="header-anchor" href="#设计原则" aria-label="Permalink to &quot;设计原则&quot;">​</a></h2><ol><li>单一职责原则</li><li>开放封闭原则 (对扩展开放,对修改封闭)</li><li>里氏替换原则 (一个对象在其出现的任何地方，都可以用子类实例做替换)</li><li>接口隔离原则</li><li>依赖倒置原则 (高层模块不应该依赖于低层模块，解耦)</li></ol><h2 id="理论" tabindex="-1">理论 <a class="header-anchor" href="#理论" aria-label="Permalink to &quot;理论&quot;">​</a></h2><p>基于抽象编程而非基于实现编程，解耦且有利于拓展性 attackBaghdad() =&gt; attack(Baghdad)</p><p>面向对象设计 ^e73d52</p><ol><li>模块划分，列出需求描述（单一职责），归类对象</li><li>筛选名词作为候选属性，动词作为候选方法，过滤筛选</li><li>定义对象之间的交互关系</li></ol><p>依赖注入：不通过new()的方式在类内部创建依赖类对象，而是将依赖类的对象在外部创建好以后，通过构造函数、函数参数等方式传递（或注入）给类使用</p><p>依赖注入框架：简单配置所有需要创建的类对象、类与类之间的依赖关系，可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等</p><h2 id="思想" tabindex="-1">思想 <a class="header-anchor" href="#思想" aria-label="Permalink to &quot;思想&quot;">​</a></h2><p>高内聚 低耦合</p><p>如何解耦？</p><ul><li>封装与抽象</li><li>中间层</li><li>模块化</li></ul><h2 id="tips" tabindex="-1">tips <a class="header-anchor" href="#tips" aria-label="Permalink to &quot;tips&quot;">​</a></h2><p>引入解释性变量后逻辑更加清晰</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SUMMER_START</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SUMMER_END</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引入解释性变量后逻辑更加清晰</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isSummer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SUMMER_START</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SUMMER_END</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isSummer) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="设计模式-1" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式-1" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><h3 id="创建型" tabindex="-1">创建型 <a class="header-anchor" href="#创建型" aria-label="Permalink to &quot;创建型&quot;">​</a></h3><ol><li><p>单例模式</p></li><li><p>工厂模式</p></li></ol><p>入参 =&gt; 成品</p><ol start="3"><li>Builder模式</li></ol><p>入参 =&gt; 半成品 =&gt; 成品</p><ol start="4"><li>原型模式</li></ol><h3 id="结构型" tabindex="-1">结构型 <a class="header-anchor" href="#结构型" aria-label="Permalink to &quot;结构型&quot;">​</a></h3><ol><li><p>代理模式</p></li><li><p>桥接模式</p></li><li><p>装饰器模式</p></li><li><p>适配器模式</p></li><li><p>门面模式</p></li><li><p>组合模式</p></li><li><p>享元模式</p></li></ol><h3 id="行为型" tabindex="-1">行为型 <a class="header-anchor" href="#行为型" aria-label="Permalink to &quot;行为型&quot;">​</a></h3><ol><li><p>观察者模式</p></li><li><p>模板模式</p></li><li><p>策略模式</p></li><li><p>职责链模式</p></li><li><p>状态模式</p></li><li><p>迭代器模式</p></li><li><p>访问者模式</p></li><li><p>备忘录模式</p></li><li><p>命令模式</p></li><li><p>解释器模式</p></li><li><p>中介模式</p></li></ol>`,27),t=[n];function h(e,k,r,d,o,E){return a(),s("div",null,t)}const y=i(p,[["render",h]]);export{g as __pageData,y as default};
