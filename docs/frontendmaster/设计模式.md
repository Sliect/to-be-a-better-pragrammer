# 设计模式

## 设计原则

1. 单一职责原则
2. 开放封闭原则 (对扩展开放,对修改封闭) 
3. 里氏替换原则 (一个对象在其出现的任何地方，都可以用子类实例做替换)
4. 接口隔离原则
5. 依赖倒置原则 (高层模块不应该依赖于低层模块，解耦)

## 理论

基于抽象编程而非基于实现编程，解耦且有利于拓展性 attackBaghdad() => attack(Baghdad)

面向对象设计  ^e73d52
1. 模块划分，列出需求描述（单一职责），归类对象
2. 筛选名词作为候选属性，动词作为候选方法，过滤筛选
3. 定义对象之间的交互关系

依赖注入：不通过new()的方式在类内部创建依赖类对象，而是将依赖类的对象在外部创建好以后，通过构造函数、函数参数等方式传递（或注入）给类使用

依赖注入框架：简单配置所有需要创建的类对象、类与类之间的依赖关系，可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等

## 思想

高内聚 低耦合

如何解耦？  
- 封装与抽象  
- 中间层  
- 模块化  

## tips

引入解释性变量后逻辑更加清晰
``` js
if (date.after(SUMMER_START) && date.before(SUMMER_END)) {
  // ...
} else {
  // ...
}

// 引入解释性变量后逻辑更加清晰
const isSummer = date.after(SUMMER_START)&&date.before(SUMMER_END);
if (isSummer) {
  // ...
} else {
  // ...
} 
```

## 设计模式

### 创建型

1. 单例模式

2. 工厂模式

入参 => 成品

3. Builder模式  

入参 => 半成品 => 成品

4. 原型模式

### 结构型

1. 代理模式

2. 桥接模式

3. 装饰器模式

4. 适配器模式

5. 门面模式

6. 组合模式

7. 享元模式

### 行为型

1. 观察者模式

2. 模板模式

3. 策略模式

4. 职责链模式

5. 状态模式

6. 迭代器模式

7. 访问者模式

8. 备忘录模式

9. 命令模式

10. 解释器模式

11. 中介模式


