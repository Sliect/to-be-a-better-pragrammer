# 算法

## 动态规划

1. 问题的base case是啥
2. 问题有什么状态
3. 对于每个状态，可以做出什么选择使得状态发生改变
4. 如何定义表现状态和选择

``` js
// 初始化base case
dp[0][0][...] = base case
for 状态1 in 状态1的所有取值
  for 状态2 in 状态2的所有取值
    for...
      dp[状态1][状态2][...] = 求最值(选择1, 选择2, 选择3)
```

## 回溯算法

1. 路径：已做出的选择
2. 选择列表：当前可以做的选择
3. 结束条件：到达决策树的底层

``` js
const result = []
function backtrack(路径, 选择列表) {
  if (满足结束条件) {
    result.push(路径)
    return
  }
  for (选择 in 选择列表) {
    做选择
    backtrack(路径, 选择列表)
    撤销选择
  }
}
```

## BFS

在图中找到目标节点的最短距离

``` js
function BFS(start, target) {
  const queue = []
  const visited = {}
  queue.push(start)
  visited[start.val] = 1
  let step = 0

  while(queue.length) {
    const len = queue.length
    for (let i = 0; i < len; i++) {
      const curr = queue.unshift()
      // 找到并退出
      if (curr.val === target.val) {
        return step
      }
      for (const child of curr.children) {
        if (visited[child.val] !== 1) {
          queue.push(child)
          visited[child.val] = 1
        }
      }
    }
    step++
  }
  return step
}
```

## 双指针

快慢指针的两者之差，用慢指针/快指针指向想要的值  
左右指针，加速遍历  

## 滑动窗口

1. right右移扩大窗口时，更新哪些数据
2. 什么条件下暂停扩大开始收缩
3. left右移缩小窗口时，更新哪些数据
4. 要的结果在扩大窗口时还是缩小窗口时更新

``` js
function minWindow(s, t) {
  let left = 0
  let right = 0
  let valid = 0
  let need = {}
  let window = {}

  for (let c of t) {
    need[c] = need[c] ? need[c] + 1 : 1
  }

  while(right < t.length) {
    const c = s[right]
    right++

    // 更新窗口数据
    if (need[c]) {
      window[c] = window[c] ? window[c] + 1 : 1
      if (need[c] === window[c]) 
        valid++
    }

    // 缩小窗口条件
    while(需要缩小窗口) {
      // 满足条件
      if (valid === Object.values(need).filter(item => item > 0).length) {
        // do something
      }
      const d = s[left]
      left++

      // 更新窗口数据
      if (need[d]) {
        if (need[d] === window[d])
          valid--
        window[d]--
      }
    }
  }
}
```

