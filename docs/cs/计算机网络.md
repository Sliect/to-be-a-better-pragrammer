# 网络是怎样连接的

## 浏览器生成消息，探索浏览器内部

1. 生成 HTTP 请求消息

解析 url 请求

http 协议定义客户端和服务器之间交互的信息内容和步骤，消息请求包括对什么进行什么操作两部分  
GET POST PUT DELETE HEAD OPTIONS TRACE CONNECT

生成 HTTP 请求

```
  <!-- 请求消息 -->
  <方法><空格><URI><空格><http版本> // 请求行
  <字段名:><字段值>                // 消息头
  ...
  <空行>
  <消息体>                        // 客户端向服务器发送的数据

  <!-- 响应消息 -->
  <http版本><空格><状态码><空格><响应短语>  // 响应行
  <字段名:><字段值>                       // 消息头
  ...
  <空行>
  <消息体>                               // 服务器向客户端发送的数据

```

消息头字段

---

通用头: 适用于请求和响应消息的头字段  
Date: 表示请求和响应生成的日期  
Pragma: 表示数据是否允许缓存的通信选项  
Cache-Control: 控制缓存的相关信息  
Connection: 设置发送响应之后 TCP 是否继续保持通信选项  
Transfer-Encoding: 表示消息主体的编码格式  
Via: 记录途中经过的代理和网关

---

请求头: 适用于请求消息的附加信息的头字段  
Authorization: 身份认证数据  
From: 请求发送者的邮件地址  
If-Modified-Since: 如果希望仅当数据在某个日期之后有更新时才执行请求，可以在这个字段指定希望的日期。一般来说，这个功能的用途在于判断客户端缓存的数据是否已经过期，如果已经过期则获取新的数据  
Refer: 当通过点击超链接进入下一个页面时，这里会记录上一个页面的 URI  
User-Agent: 客户端软件的名称和版本号等相关信息  
Accept: 客户端可支持的数据类型，以 MIME 类型表示  
Accept-Charset: 客户端可支持的字符集  
Accept-Encoding: 客户端可支持的编码格式，一般来说表示数据的压缩格式  
Accept-Language: 客户端可支持的语言  
Host: 接收请求的服务器 IP 和端口号  
If-Match: 参见 Etag  
If-None-Match: 参见 Etag  
If-Unmodified-Since: 当置顶日期之后数据未更新时执行请求  
Range: 当需要只获取部分数据而不是全部数据时，可通过这个字段指定获取的数据范围

---

响应头: 适用于响应消息的附加信息的头字段  
Location: 表示信息的准确位置。当请求的 URI 为相对路径时，这个字段用来返回绝对路径  
Server: 服务器程序的名称和版本号等相关信息  
WWW-Authenticate: 当请求的信息存在访问控制时，返回身份认证用的数据  
Accept-Ranges: 当希望请求部分数据时，服务器会告知客户端是否支持这一功能

---

实体头: 用于表示实体（消息体）的附加信息的头字段  
Allow: 表示指定的 URI 支持的方法  
Content-Encoding: 当消息体经过压缩等编码处理时，表示其编码格式  
Content-Type: 表示消息体的数据类型，以 MIME 规格定义的数据类型来表示  
Expires: 表示消息体的有效期  
Last-Modified: 表示上次修改时间  
Content-Language: 表示消息体的语言  
Content-Location: 表示消息体在服务器上的位置（URI）  
Content-Range: 当仅请求部分数据时，表示消息体包含的数据范围  
Etag: 在更新操作中，有时候需要基于上一次请求的响应数据来发送下一次请求。在这种情况下，这个字段可以用来提供上次响应与下次请求之间的关联信息。上次响应中，服务器会通过 Etag 向客户端发送一个唯一标识，在下次请求中客户端可以通过 If- Match、If-None-Match、If-Range 字段将这个标识告知服务器，这样服务器就知道该请求和上次的响应是相关的。这个字段的功能和 Cookie 是相同的，但 Cookie 是网景（Netscape）公司自行开发的规格，而 Etag 是将其进行标准化后的规格

---

2. 向 DNS 服务器查询 Web 服务器的 IP 地址

IP 地址 [10. 11. 12. 13]  
前三位表示网络号，对应整个子网的地址  
最后一位表示主机号，对应主机的地址，当主机号为 0 时表示整个子网，当主机号为 255 时，这个地址会对整个子网进行广播  
子网掩码对应网络号的位置都为 1，对应主机号的位置都为 0

DNS 的客户端叫解析器，解析器调用调用协议栈向 DNS 服务器发送查询消息

3. 全世界 DNS 服务器的大接力

查询消息包括
域名  
Class: IN 表示互联网，其它的网络都被淘汰了  
记录类型: A(IP 地址)/MX(邮件服务器)

4. 委托协议栈发送消息

服务器首先创建套接字，等待客户端向该套接字连接管道  
客户端创建套接字，连接管道  
双方建立通信  
断开通道并删除套接字

## 用电信号传输 TCP/IP 数据，探索协议栈和网卡

1. 创建套接字

协议栈内部  
应用程序：（浏览器、服务器等）向 socket 委派收送数据的工作  
操作系统：像浏览器、邮件等一般应用程序用 TCP 收发数据，像 DNS 查询等收发较短的控制数据的时候用 UDP，用 IP 协议控制网络包收发操作  
驱动程序：控制网卡硬件  
硬件：完成实际的收发操作

2. 连接服务器

客户端先创建一个包含表示开始数据收发操作的控制信息的头部,靠头部的发送方和接收方的端口号，找到服务器的套接字并将 SYN 设置为 1 表示已连接,TCP 模块委托 IP 模块发送信息，IP 模块将网络包通过网络送到服务器  
服务器上的 IP 模块会将收到的数据传递给 TCP 模块，TCP 模块根据 TCP 头部中的端口号找到对应的套接字，并在套接字中将状态改为正在连接，TCP 返回响应，在 TCP 头部设置接收方和发送方的端口以及 SYN，并将 ACK 设为 1，表示已经收到网络包，然后委托 IP 模块向客户端返回响应  
网络包回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部信息确认连接服务器是否成功，如果 SYN 为 1 表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时将状态改为连接完毕，客户端将 ACK 设置为 1 并发回给服务器，告诉服务器已经收到响应包  
服务器收到返回包，连接完成

3. 收发数据

将数据存放到内部的发送缓冲区中，控制网络包的数据不至于过小，另一个判断要素是时间，当到了协议栈内部的计时器设置的时间后，也会将网络包发送出去
TCP 拆分过大的数据包，然后添加到数据块的头部，再将 IP 添加到头部，如下所示：  
[MAC][ip][TCP][数据块]  
TCP 还要确认对方是否成功收到网络包，以及在对方没收到时进行重发的功能  
发送方说：从 xx 字节开始，一共有 xx 字节  
接收方说：到 xx 字节之前的数据我都收到了  
通过序号和 ACK 号可以确认对方收到了网络包  
ACK 号表示的是已收到的数据量

优化：  
ACK 采用的是根据网络包平均往返时间自动调节 ACK 等待时间，滑动窗口管理 ACK 号，即不等待 ACK 号返回后续直接发送一连续的包，但是这样会产生一个问题：当接收方收到的包过多时，接收方的接收缓存区会溢出。为避免发生这种情况，接收方会向发送方告知其剩余空间数。

总结：协议栈会检查收到的数据块和 TCP 头部内容，判断数据是否有丢失，如果没有则返回 ACK 号。然后协议栈将数据块缓存到接收缓存区中，并将数据块按顺序连接起来还原原始数据交给应用程序。即协议栈将收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还会找到合适的时机向发送方发送窗口更新。

4. 从服务器断开连接并删除套接字

完成数据发送的一方发起断开请求，调用 Socket 中的 close 程序，然后协议栈生成包含断开信息的头部，将控制位中 FIN 设为 1，接下来委托 IP 模块发送数据。  
接收方收到 FIN 为 1 的头部信息时，将自己的套接字标记为进入断开操作状态，然后告知发送方已收到 FIN 为 1 的包，并返回一个 ACK 号。  
接收方同理，发起一个断开请求，结束通信。  
之后套接字并不会立刻被删除，是为了防止重发断开请求被新的套接字收到，导致被误操作。一般来说会等待几分钟

数据收发操作总结：  
创建套接字  
客户端发起连接操作。首先生成一个 SYN 为 1 的 TCP 包发送给服务器，TCP 头部还包含了数据的序号以及客户端的窗口大小，服务器收到网络包后返回一个 SYN 为 1 的 TCP 包，头部包含序号和服务器的窗口大小还有 ACK 号。客户端收到后返回一个包含 ACK 号的 TCP 包，连接成功。  
数据收发操作。TCP 将请求切成一定大小的块，并在每一个块前加上 TCP 头部，然后发送给服务器，服务器返回 ACK 号和窗口大小，完成一次请求。服务器响应和客户端请求相反，由服务器发起。  
断开操作。一方发起断开请求，发送 FIN 为 1 的 TCP 包，另一方返回 ACK 号。之后右另一方发起断开请求，同上。最后等待一段时间后，删除套接字。

5. IP 与以太网的包收发操作

``` ts
// 结构如下
// <MAC 头部><IP 头部><TCP 头部><数据块>
```

MAC 头部用于以太网协议  
IP 头部用于 IP 协议

IP 协议根据目标地址查找包的传输方向，找到下一个路由器 MAC 地址，舍弃旧的 MAC 头部，加上新的 MAC 头部。将 IP 和以太网分工的好处是可以将以太网替换成其它的如无线局域网、ADSL 等，架构上更加灵活

MAC 头部包含了接收方和发送方的 MAC 地址，还有协议类型

ARP 查询接收方的 MAC 地址

6. 用 UDP 协议收发数据的操作

不需要重发的数据用 UDP 发送更高效

## 从网线到网络设备，探索集线器、交换机和路由器

1. 信号在网线和集线器中传输

客户端经过集线器、交换机和路由器进入互联网，家用路由器已经继承了集线器和交换机的功能

通信中的噪声：网线周围存在电磁波，就会在网线中产生电流，与原有信号混在在一起  
抑制噪声：双绞线螺旋缠绕，将噪声电流相互抵消，原有信号不变

以太网的基本架构就是将包发送到所有设备，由设备根据接收方 MAC 地址判断应该接收哪些包，集线器也是一样的架构

2. 交换机的包转发操作

交换机先接收信号并将其还原为数字信息，然后再重新转换成信号并发送出去

3. 路由器的包转发操作

路由器的包转发和交换机类似，也是通过查表判断包转发的目标。区别是交换机是基于以太网设计，路由器是基于 IP 设计

IP 本身不负责包的传输，而是委托各种通信技术将包传输到下一个路由器

4. 路由器的附加功能

地址转换：转发网络包时对 IP 头部中的 IP 地址和端口号进行改写  
包过滤：根据 MAC 头部、TCP 头部、IP 头部内容判断对包进行转发还是丢弃操作

## 通过接入网进入互联网内部，探索接入网和网络运营商

1. ADSL 接入网的结构和工作方式

2. 光纤接入网（FTTH）

数字信息 => 电信号 => 光信号传输 => 电信号 => 数字信息

3. 接入网中使用的 PPP 和隧道

4. 网络运营商的内部

用户通过各种入网方式接入运营商的路由器，再经由交换机进入骨干网的路由器

5. 跨越运营商的网络包

## 服务器端的局域网中有什么玄机

1. Web 服务器的部署地点

和路由器直连、通过防火漆隔离、部署在数据中心

2. 防火墙的结构和原理

根据包的流动方向设置过滤规则

3. 通过将请求平均分配给多台服务器来平衡负载

如何判断请求发送给哪台 web 服务器？ 判断操作是否跨多个页面，因为 http 请求是相互独立的，无法判断请求之间的关联性，所以用 cookie 来判断

4. 利用缓存服务器分担负载

客户端向缓存服务器发起请求，缓存服务器检查请求的数据是否在缓存中。假设不存在，将消息转发给服务器，服务器返回响应内容，缓存服务器将数据缓存下来并记录保存的时间，然后转发给客户端；假设存在，缓存服务器会添加一个 If-Modified-Since 的头部字段并转发请求给服务器，询问请求的数据是否已经发生变化，服务器根据 If-Modified-Since 的值和服务器上数据的最后更新时间进行比较，如果在指定时间内没有变化，则返回一个没有变化的响应消息，缓存服务器就会将缓存数据转发给客户端，如果在指定时间内发生变化，和没有命中缓存的情况一样。

正向代理：客户端侧的代理服务器，可以缓存数据、根据请求内容过滤网站，有正向代理时，请求头上的 URI 信息是完整网址，没有正向代理时，是相对的文件名和目录名。客户端侧的缓存服务器和服务端侧的缓存服务器区别是，客户端的缓存服务器可以根据完整 URI 向任意服务器发送请求，而服务器侧的缓存服务器只能向事先设置好的目标服务器进行转发

5. 内容分发服务

将缓存服务器部署在 web 服务器侧，可以降低 web 服务器的负载，无法减少网络流量  
将缓存服务器部署在客户端侧，可以减少网络流量，web 服务器运营者无法控制客户端侧的缓存服务器  
将缓存服务器部署在互联网的边缘，可以降低网络流量，web 服务器运营者也可以控制缓存服务器

## 请求到达 Web 服务器，响应返回浏览器，短短几秒的“漫长旅程”迎来终点

1. 服务器概览

服务器启动读取配置文件完成初始化操作，运行等待连接模块，该模块会创建套接字，然后进入待连接的暂停状态，当客户端发起连接时，该模块恢复运行，然后启动客户端通信模块，并复制新的套接字让客户端通信模块和客户端进行通信，通信结束后退出该模块，通信模块和客户端是一对一的。有新的客户端发起连接时可以创建新的通信模块，也可以预先启动多个通信模块，在其中挑选出空闲的一个移交套接字进行通信

服务器上存在多个端口相同的套接字，客户端上的套接字都是不同的端口。服务器上多个相同的端口可以对应不同客户端发起的套接字连接，服务器上不同的端口对应同一个客户端发起的连接。服务端 IP+端口+客户端 IP+端口可以确认网络包的流向

2. 服务器的接收操作

网卡驱动会根据 MAC 头部判断协议类型，并将包交给相应的协议栈  
协议栈的 IP 模块会检查 IP 头部，判断是不是发给自己的，对于不是发给自己的，会像路由器一样根据路由表对包进行转发。接下来判断包有没有分片，若分片则将包存放在内存中，等所有包到达之后将分片组装起来还原成原始包，若没有分片，则直接保留不变。最后根据 IP 头部的协议号字段，将包转发给 TCP 模块或者 UDP 模块  
TCP 模块判断 TCP 头部中的 SYN 为 1，表示收到的是发起连接的包，然后检查接收方端口号，若指定端口没有等待连接的套接字，则返回错误通知的包，若存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方的 IP 地址、端口号、序号初始值、窗口大小等参数写入这个套接字，同时分配用于发送缓冲区和接收缓冲区的内存空间。然后生成代表接收确认的 ACK 号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口大小，并用这些信息生成 TCP 头部，委托 IP 模块发送给客户端。客户端收到后返回表示确认的 ACK 号，连接操作就完成了  
TCP 模块处理数据包，TCP 模块根据接收方的 IP 地址、端口号和发送方的 IP 地址和端口号，找到所有匹配的套接字，根据套接字中保存的上一个序号和数据长度计算下一个序号，并检查与收到的包的 TCP 头部中的序号是否一致，如果一致表示正常到达了服务器，TCP 模块会从包中取出数据，与上次收到的数据块连接起来存放到接收缓冲区中，然后 TCP 模块生成确认应答的 TCP 头部，根据接受包的序号和数据长度计算出 ACK 号，委托 IP 模块发送给客户端  
服务器的 TCP 模块生成一个控制位 FIN 为 1 的 TCP 头部，委托 IP 模块发送给客户端。客户端返回一个 ACK 号后调用 close，也生成一个 FIN 为 1 的 TCP 头部发送给服务器，服务器返回一个 ACK 号，表示断开操作完成，一段时间后套接字会被删除。在 http1.1 中是客户端先发起的断开操作

3. Web 服务器程序解释请求消息并作出响应

web 服务器公开的目录不是磁盘上的实际目录，而是虚拟目录，这样 URI 请求就只能为虚拟目录上存在的文件，从而保证了其它文件的私密性。

URI 指定的文件为一个程序时，web 服务器会委托操作系统运行该程序，然后将请求消息中的参数交给运行的程序，程序执行后将输出数据返回给 web 服务器，服务器将返回数据和套接字的描述符交给协议栈，协议栈委托 IP 模块返回给客户端

4. 浏览器接收消息并显示内容

数据根据 Content-Type 的值来判断数据类型，Content-Type: text/html 中的/左边表示主类型，表示数据的大分类，右边的子分类表示具体的数据类型，浏览器根据具体数据类型显示内容


# 计算机网络

## 计算机网络和因特网

TCP：传输控制协议  
IP：网际协议  
